import { Injectable } from '@angular/core';
import { StyleService } from './style.service';
import { serialize } from '@thi.ng/hiccup';

interface MineStyleParams {
  mineName?: string;
  optionalFilters?: OptionalFilter[];
}

interface OptionalFilter {
  value: string;
  label: string;
  xpath: string;
  predicate: string;
  type: string;
  added: boolean;
}

@Injectable()
export class MineStyleService {
  constructor(private styleService: StyleService) {}

  public static getSld(layerName: string, styleName: string, params: MineStyleParams): string {
    const ns = {
      sld: 'http://www.opengis.net/sld',
      ogc: 'http://www.opengis.net/ogc',
      gml: 'http://www.opengis.net/gml',
      er: 'urn:cgi:xmlns:GGIC:EarthResource:1.1',
      gsml: 'urn:cgi:xmlns:CGI:GeoSciML:2.0',
      xlink: 'http://www.w3.org/1999/xlink',
      xsi: 'http://www.w3.org/2001/XMLSchema-instance'
    };

    // Create filter fragments
    const fragments = [];

    // Add base filter for mine name if provided
    if (params.mineName) {
      fragments.push(['ogc:PropertyIsLike', { wildCard: '*', singleChar: '#', escapeChar: '!' },
        ['ogc:PropertyName', {}, 'er:specification/er:Mine/er:mineName/er:MineName/er:mineName'],
        ['ogc:Literal', {}, `*${params.mineName}*`]
      ]);
    }

    // Process optional filters
    if (params.optionalFilters) {
      params.optionalFilters.forEach(filter => {
        switch (filter.type) {
          case 'OPTIONAL.POLYGONBBOX':
            fragments.push(['ogc:Intersects', {},
              ['ogc:PropertyName', {}, 'er:location'],  // Use er:location as per backend
              ['gml:Polygon', {}, filter.value]
            ]);
            break;
          case 'OPTIONAL.TEXT':
            fragments.push(['ogc:PropertyIsLike', { wildCard: '*', singleChar: '#', escapeChar: '!' },
              ['ogc:PropertyName', {}, filter.xpath],
              ['ogc:Literal', {}, `*${filter.value}*`]
            ]);
            break;
        }
      });
    }

    // Create filter
    const filter = fragments.length > 0 ? 
      ['ogc:Filter', {},
        fragments.length > 1 
          ? ['ogc:And', {}, ...fragments]
          : fragments[0]
      ] : null;

    return serialize(
      ['sld:StyledLayerDescriptor', {
        version: '1.0.0',
        ...this.generateNamespaces(ns)
      },
        ['sld:NamedLayer', {},
          ['sld:Name', {}, layerName],
          ['sld:UserStyle', {},
            ['sld:Name', {}, styleName],
            ['sld:Title', {}, styleName],
            ['sld:Abstract', {}, 'Mine style generated by AuScope Portal'],
            ['sld:IsDefault', {}, '1'],
            ['sld:FeatureTypeStyle', {},
              ['sld:Rule', {},
                filter,
                this.createSymbolizer('#FF9900')
              ]
            ]
          ]
        ]
      ]
    );
  }

  private static generateNamespaces(ns: any): object {
    return Object.entries(ns).reduce((acc, [key, value]) => ({
      ...acc,
      [`xmlns:${key}`]: value
    }), {});
  }

  private static createSymbolizer(color: string): any[] {
    return [
      'sld:PointSymbolizer', {},
      ['sld:Graphic', {},
        ['sld:Mark', {},
          ['sld:WellKnownName', {}, 'circle'],
          ['sld:Fill', {},
            ['sld:CssParameter', { name: 'fill' }, color],
            ['sld:CssParameter', { name: 'fill-opacity' }, '0.4']
          ],
          ['sld:Stroke', {},
            ['sld:CssParameter', { name: 'stroke' }, color],
            ['sld:CssParameter', { name: 'stroke-width' }, '1']
          ]
        ],
        ['sld:Size', {}, '8']
      ]
    ];
  }
} 