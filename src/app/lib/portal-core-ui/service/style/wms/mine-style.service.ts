import { Injectable } from '@angular/core';
import { OptionalFilter, StyleService } from './style.service';
import { serialize } from '@thi.ng/hiccup';

interface MineStyleParams {
  mineName?: string;
  optionalFilters?: OptionalFilter[];
}

/**
 * MineStyleService
 * Note: Hasn't been fully refactored to use StyleService methods due to polygon differences.
 */
@Injectable()
export class MineStyleService {

  public static getSld(layerName: string, styleName: string, params: MineStyleParams): string {
    const ns = {
      sld: 'http://www.opengis.net/sld',
      ogc: 'http://www.opengis.net/ogc',
      gml: 'http://www.opengis.net/gml',
      er: 'urn:cgi:xmlns:GGIC:EarthResource:1.1',
      gsml: 'urn:cgi:xmlns:CGI:GeoSciML:2.0',
      xlink: 'http://www.w3.org/1999/xlink',
      xsi: 'http://www.w3.org/2001/XMLSchema-instance'
    };

    // Create filter fragments
    const fragments = [];

    // Add base filter for mine name if provided
    if (params.mineName) {
      fragments.push(['ogc:PropertyIsLike', { wildCard: '*', singleChar: '#', escapeChar: '!' },
        ['ogc:PropertyName', {}, 'er:specification/er:Mine/er:mineName/er:MineName/er:mineName'],
        ['ogc:Literal', {}, `*${params.mineName}*`]
      ]);
    }

    // Process optional filters
    if (params.optionalFilters) {
      params.optionalFilters.forEach(filter => {
        switch (filter.type) {
          case 'OPTIONAL.POLYGONBBOX':
            fragments.push(['ogc:Intersects', {},
              ['ogc:PropertyName', {}, 'er:location'], // Use er:location as per backend
              ['gml:Polygon', {}, filter.value]
            ]);
            break;
          case 'OPTIONAL.TEXT':
            fragments.push(['ogc:PropertyIsLike', { wildCard: '*', singleChar: '#', escapeChar: '!' },
              ['ogc:PropertyName', {}, filter.xpath],
              ['ogc:Literal', {}, `*${filter.value}*`]
            ]);
            break;
        }
      });
    }

    // Create filter
    const filter = fragments.length > 0 ?
      ['ogc:Filter', {},
        fragments.length > 1
          ? ['ogc:And', {}, ...fragments]
          : fragments[0]
      ] : null;

    return serialize(
      ['sld:StyledLayerDescriptor', {
        version: '1.0.0',
        ...this.generateNamespaces(ns)
      },
        ['sld:NamedLayer', {},
          ['sld:Name', {}, layerName],
          ['sld:UserStyle', {},
            ['sld:Name', {}, styleName],
            ['sld:Title', {}, styleName],
            ['sld:Abstract', {}, 'Mine style generated by AuScope Portal'],
            ['sld:IsDefault', {}, '1'],
            ['sld:FeatureTypeStyle', {},
              ['sld:Rule', {},
                filter,
                StyleService.createSymbolizer('#FF9900', 'circle', '1')
              ]
            ]
          ]
        ]
      ]
    );
  }

  private static generateNamespaces(ns: any): object {
    return Object.entries(ns).reduce((acc, [key, value]) => ({
      ...acc,
      [`xmlns:${key}`]: value
    }), {});
  }
}
