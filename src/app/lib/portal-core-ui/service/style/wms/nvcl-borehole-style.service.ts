import { Injectable } from '@angular/core';
import { StyleService } from './style.service';
import { serialize } from '@thi.ng/hiccup';
interface NVCLBoreholeStyleParams {
  filterNames: string[];
  filters: string[];
  filterColors: string[];
  filterMarks: string[];
  gsmlpNamespace: string;
  showLabels?: boolean;
  analyticsResults?: {
    passBoreholes?: string[];
    failBoreholes?: string[];
    errorBoreholes?: string[];
  };
  optionalFilters?: OptionalFilter[];
}
interface OptionalFilter {
  value: string;
  label: string;
  xpath: string;
  predicate: string;
  type: string;
  added: boolean;
}
@Injectable()
export class NVCLBoreholeStyleService {
  constructor(private styleService: StyleService) {}
  public static getSld(
    layerName: string,
    styleName: string,
    param: NVCLBoreholeStyleParams
  ): string {
    const styleParams = {
      filters: [],
      filterColors: ['#FF0000'],
      filterMarks: ['circle'],
      filterNames: ['Boreholes'],
      gsmlpNamespace:
        param?.gsmlpNamespace ||
        'http://xmlns.geosciml.org/geosciml-portrayal/4.0',
      showLabels: param?.showLabels !== false,
      analyticsResults: param?.analyticsResults,
      optionalFilters: param?.optionalFilters,
    };
    const ns = {
      sld: 'http://www.opengis.net/sld',
      ogc: 'http://www.opengis.net/ogc',
      gml: 'http://www.opengis.net/gml',
      gsml: 'urn:cgi:xmlns:CGI:GeoSciML:2.0',
      gsmlp: styleParams.gsmlpNamespace,
      xlink: 'http://www.w3.org/1999/xlink',
      xsi: 'http://www.w3.org/2001/XMLSchema-instance',
    }; // Get base filters from optional filters
    const baseFilter = this.createBaseFilter(styleParams.optionalFilters || []); // Generate rules based on analytics results or hylogged status
    const rules = styleParams.analyticsResults
      ? this.createAnalyticsRules(styleParams.analyticsResults, baseFilter, ns)
      : this.createHyloggedRules(baseFilter, ns);
    return serialize([
      'sld:StyledLayerDescriptor',
      {
        version: '1.0.0',
        'xmlns:sld': ns.sld,
        'xmlns:ogc': ns.ogc,
        'xmlns:gml': ns.gml,
        'xmlns:gsml': ns.gsml,
        'xmlns:gsmlp': ns.gsmlp,
        'xmlns:xlink': ns.xlink,
        'xmlns:xsi': ns.xsi,
        'xsi:schemaLocation': [
          `${ns.sld} StyledLayerDescriptor.xsd`,
          `${ns.gml} http://schemas.opengis.net/gml/3.1.1/base/gml.xsd`,
          `${ns.gsml} http://schemas.geosciml.org/geosciml/2.0/geosciml.xsd`,
        ].join(' '),
      },
      [
        'sld:NamedLayer',
        {},
        ['sld:Name', {}, layerName],
        [
          'sld:UserStyle',
          {},
          ['sld:Name', {}, styleName],
          ['sld:Title', {}, styleName],
          [
            'sld:Abstract',
            {},
            'NVCL Borehole style generated by AuScope Portal',
          ],
          ['sld:IsDefault', {}, '1'],
          baseFilter,
          ...rules,
        ],
      ],
    ]);
  }
  private static createBaseFilter(filters: OptionalFilter[]): string {
    const filterParts: string[] = []; // Add hylogged filter - always required for NVCL
    const hylogged = this.createHyloggedFilter();
    filterParts.push(hylogged); // Process optional filters
    filters.forEach((filter) => {
      switch (filter.type) {
        case 'OPTIONAL.POLYGONBBOX':
          const poly = this.createPolygonFilter(filter);
          filterParts.push(poly);
          break;
        case 'OPTIONAL.DATE':
          const date = this.createDateFilter(filter);
          filterParts.push(date);
          break;
        case 'OPTIONAL.TEXT':
          if (filter.xpath === 'gsmlp:name') {
            // Handle name filter with substring search (contains)
            const searchValue = filter.value ? `*${filter.value}*` : '*';
            const nameFilterXml = `<ogc:PropertyIsLike wildCard="*" singleChar="#" escapeChar="!" matchCase="false">
              <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
              <ogc:Literal>${searchValue}</ogc:Literal>
            </ogc:PropertyIsLike>`;
            filterParts.push(nameFilterXml);
          } else if (
            filter.xpath === 'gsmlp:boreholeLength_m' &&
            (filter.predicate === 'BIGGER_THAN' ||
              filter.predicate === 'SMALLER_THAN')
          ) {
            // Handle numeric length filters
            const operator =
              filter.predicate === 'BIGGER_THAN'
                ? 'PropertyIsGreaterThan'
                : 'PropertyIsLessThan';
            const lengthFilterXml = `<ogc:${operator}>
              <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
              <ogc:Literal>${filter.value}</ogc:Literal>
            </ogc:${operator}>`;
            filterParts.push(lengthFilterXml);
          } else if (filter.xpath === 'gsmlp:identifier') {
            // Handle identifier filter with substring search (contains)
            const searchValue = filter.value ? `*${filter.value}*` : '*';
            const identifierFilterXml = `<ogc:PropertyIsLike wildCard="*" singleChar="#" escapeChar="!" matchCase="false">
              <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
              <ogc:Literal>${searchValue}</ogc:Literal>
            </ogc:PropertyIsLike>`;
            filterParts.push(identifierFilterXml);
          }
          break;
      }
    });
    let combined;
    if (filterParts.length > 1) {
      combined = `<ogc:Filter><ogc:And>${filterParts.join(
        ''
      )}</ogc:And></ogc:Filter>`;
    } else {
      combined = filterParts[0];
    }
    return combined;
  }
  private static createPolygonFilter(filter: OptionalFilter): string {
    return `<ogc:Intersects>
             <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
             ${filter.value}
             </ogc:Intersects>`;
  }
  private static createDateFilter(filter: OptionalFilter): string {
    const operator =
      filter.predicate === 'BIGGER_THAN'
        ? 'PropertyIsGreaterThan'
        : 'PropertyIsLessThan';
    return `<ogc:${operator}>
             <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
             <ogc:Literal>${filter.value}</ogc:Literal>
             </ogc:${operator}>`;
  }
  private static createHyloggedFilter(): string {
    return `<ogc:PropertyIsEqualTo>
             <ogc:PropertyName>gsmlp:nvclCollection</ogc:PropertyName>
             <ogc:Literal>true</ogc:Literal>
            </ogc:PropertyIsEqualTo>`;
  }
  private static createAnalyticsRules(
    analytics: any,
    baseFilter: string,
    ns: any
  ): any[] {
    const rules = [];
    if (analytics.errorBoreholes?.length > 0) {
      rules.push(
        this.createRule(
          'Error Boreholes',
          this.combineFilters([
            baseFilter,
            this.createIdentifierFilter(analytics.errorBoreholes),
          ]),
          '#ff8000',
          'circle',
          ns
        )
      );
    }
    if (analytics.failBoreholes?.length > 0) {
      rules.push(
        this.createRule(
          'Fail Boreholes',
          this.combineFilters([
            baseFilter,
            this.createIdentifierFilter(analytics.failBoreholes),
          ]),
          '#cc0000',
          'circle',
          ns
        )
      );
    }
    if (analytics.passBoreholes?.length > 0) {
      rules.push(
        this.createRule(
          'Pass Boreholes',
          this.combineFilters([
            baseFilter,
            this.createIdentifierFilter(analytics.passBoreholes),
          ]),
          '#0000ff',
          'circle',
          ns
        )
      );
    }
    return rules;
  }
  private static createHyloggedRules(baseFilter: string, ns: any): any[] {
    return [this.createRule('Hylogged', baseFilter, '#FF0000', 'circle', ns)];
  }
  private static createIdentifierFilter(identifiers: string[]): string {
    if (!identifiers?.length) return '';
    const conditions = identifiers.map(
      (id) => `<ogc:PropertyIsEqualTo>
                <ogc:PropertyName>gsmlp:identifier</ogc:PropertyName>
                <ogc:Literal>${id}</ogc:Literal>
              </ogc:PropertyIsEqualTo>`
    );
    return conditions.length > 1
      ? `<ogc:Or>${conditions.join('')}</ogc:Or>`
      : conditions[0];
  }
  private static combineFilters(filters: string[]): string {
    const validFilters = filters.filter((f) => f);
    return validFilters.length > 1
      ? `<ogc:Filter><ogc:And>${validFilters.join('')}</ogc:And></ogc:Filter>`
      : `<ogc:Filter>${validFilters[0]}</ogc:Filter>`;
  } // Reuse methods from BoreholeStyleService
  private static createRule(
    name: string,
    filter: string,
    color: string,
    mark: string,
    ns: any
  ): any[] {
    const filterXml = filter
      ? filter.includes('<ogc:Filter>')
        ? filter
        : ['ogc:Filter', {}, filter]
      : this.generateDefaultFilter(ns);
    return [
      'sld:FeatureTypeStyle',
      {},
      [
        'sld:Rule',
        {},
        ['sld:Name', {}, name],
        ['sld:MaxScaleDenominator', {}, '4000000'],
        typeof filterXml === 'string' ? filterXml : filterXml,
        this.createSymbolizer(color, mark, ns),
        this.createLabelSymbolizer(ns),
      ],
      [
        'sld:Rule',
        {},
        ['sld:MinScaleDenominator', {}, '4000000'],
        typeof filterXml === 'string' ? filterXml : filterXml,
        this.createSymbolizer(color, mark, ns),
      ],
    ];
  }
  private static createSymbolizer(color: string, mark: string, ns: any): any[] {
    return [
      'sld:PointSymbolizer',
      {},
      [
        'sld:Graphic',
        {},
        [
          'sld:Mark',
          {},
          ['sld:WellKnownName', {}, mark],
          [
            'sld:Fill',
            {},
            ['sld:CssParameter', { name: 'fill' }, color],
            ['sld:CssParameter', { name: 'fill-opacity' }, '0.4'],
          ],
          [
            'sld:Stroke',
            {},
            ['sld:CssParameter', { name: 'stroke' }, color],
            ['sld:CssParameter', { name: 'stroke-width' }, '0.5'],
          ],
        ],
        ['sld:Size', {}, '8'],
      ],
    ];
  }
  private static createLabelSymbolizer(ns: any): any[] {
    return [
      'sld:TextSymbolizer',
      {},
      [
        'sld:Label',
        {},
        [
          'ogc:Function',
          { name: 'strSubstringStart' },
          ['ogc:PropertyName', {}, 'gsmlp:name'],
          ['ogc:Function', { name: 'parseInt' }, ['ogc:Literal', {}, '27']],
        ],
      ],
      [
        'sld:Font',
        {},
        ['sld:CssParameter', { name: 'font-family' }, 'Arial'],
        ['sld:CssParameter', { name: 'font-size' }, '12'],
      ],
      [
        'sld:LabelPlacement',
        {},
        [
          'sld:PointPlacement',
          {},
          [
            'sld:Displacement',
            {},
            ['sld:DisplacementX', {}, '6'],
            ['sld:DisplacementY', {}, '-6'],
          ],
        ],
      ],
      ['sld:Fill', {}, ['sld:CssParameter', { name: 'fill' }, '#000000']],
    ];
  }
  private static generateDefaultFilter(ns: any): string {
    return `<ogc:Filter><ogc:PropertyIsLike wildCard="*" singleChar="#" escapeChar="!">
              <ogc:PropertyName>gsmlp:name</ogc:PropertyName>
              <ogc:Literal>*</ogc:Literal>
            </ogc:PropertyIsLike></ogc:Filter>`;
  }
}
