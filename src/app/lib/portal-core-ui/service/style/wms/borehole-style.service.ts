import { Injectable } from '@angular/core';
import { OptionalFilter, StyleService } from './style.service';
import { serialize } from '@thi.ng/hiccup';

interface BoreholeStyleParams {
  filterNames?: string[];
  filters?: string[];
  filterColors?: string[];
  filterMarks?: string[];
  gsmlpNamespace: string;
  showLabels?: boolean;
  showNoneHylogged?: boolean;
  optionalFilters?: OptionalFilter[];
}

@Injectable()
export class BoreholeStyleService {
  public static getSld(layerName: string, styleName: string, param: BoreholeStyleParams): string {
    const styleParams = {
        gsmlpNamespace:
          param?.gsmlpNamespace ||
          'http://xmlns.geosciml.org/geosciml-portrayal/4.0',
        showLabels: param?.showLabels !== false,
        showNoneHylogged: param?.showNoneHylogged,
        optionalFilters: param?.optionalFilters,
      };
    const ns = {
      sld: 'http://www.opengis.net/sld',
      ogc: 'http://www.opengis.net/ogc',
      gml: 'http://www.opengis.net/gml',
      gsml: 'urn:cgi:xmlns:CGI:GeoSciML:2.0',
      gsmlp: styleParams.gsmlpNamespace,
      xlink: 'http://www.w3.org/1999/xlink',
      xsi: 'http://www.w3.org/2001/XMLSchema-instance'
    };

    // Create rules based on filters
    const rules = this.createBoreholeRules(styleParams);

    return serialize(
      ['sld:StyledLayerDescriptor', {
        version: '1.0.0',
        'xmlns:sld': ns.sld,
        'xmlns:ogc': ns.ogc,
        'xmlns:gml': ns.gml,
        'xmlns:gsml': ns.gsml,
        'xmlns:gsmlp': ns.gsmlp,
        'xmlns:xlink': ns.xlink,
        'xmlns:xsi': ns.xsi,
        'xsi:schemaLocation': [
          `${ns.sld} StyledLayerDescriptor.xsd`,
          `${ns.gml} http://schemas.opengis.net/gml/3.1.1/base/gml.xsd`,
          `${ns.gsml} http://schemas.geosciml.org/geosciml/2.0/geosciml.xsd`
        ].join(' ')
      },
        ['sld:NamedLayer', {},
          ['sld:Name', {}, layerName],
          ['sld:UserStyle', {},
            ['sld:Name', {}, styleName],
            ['sld:Title', {}, styleName],
            ['sld:Abstract', {}, 'Borehole style generated by AuScope Portal'],
            ['sld:IsDefault', {}, '1'],
            ...rules
          ]
        ]
      ]
    );
  }

  private static createBoreholeRules(params: BoreholeStyleParams): any[] {
    const rules = [];

    // Add regular boreholes
    const baseFilter = this.createBaseFilter(params.optionalFilters || []);
    rules.push(StyleService.createRule(
      'Boreholes',
      baseFilter,
      '#2242c7',
      'circle',
      '0.5'
    ));

    // Add hylogged boreholes if requested
    if (params.showNoneHylogged) {
      const hyloggedFilter = this.combineFilters([
        baseFilter,
        this.createHyloggedFilter()
      ]);
      rules.push(StyleService.createRule(
        'Hylogged',
        hyloggedFilter,
        '#FF0000',
        'circle',
        '0.5'
      ));
    }

    return rules;
  }

  private static createBaseFilter(filters: OptionalFilter[]): string {
    const filterParts: string[] = [];

    // Process optional filters
    filters.forEach(filter => {
      switch (filter.type) {
        case 'OPTIONAL.POLYGONBBOX':
          filterParts.push(this.createPolygonFilter(filter));
          break;
        case 'OPTIONAL.DATE':
          filterParts.push(this.createDateFilter(filter));
          break;
        case 'OPTIONAL.TEXT':
          if (filter.xpath === 'gsmlp:name') {
            // Handle name filter with substring search (contains)
            const searchValue = filter.value ? `*${filter.value}*` : '*';
            const nameFilterXml = `<ogc:PropertyIsLike wildCard="*" singleChar="#" escapeChar="!" matchCase="false">
            <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
            <ogc:Literal>${searchValue}</ogc:Literal>
            </ogc:PropertyIsLike>`;
            filterParts.push(nameFilterXml);
          }
          break;
        }
    });

    // Combine all filters with AND
    return filterParts.length > 1
      ? `<ogc:Filter><ogc:And>${filterParts.join('')}</ogc:And></ogc:Filter>`
      : filterParts[0] || StyleService.generateDefaultFilter();
  }

  private static createPolygonFilter(filter: OptionalFilter): string {
    return `<ogc:Intersects>
      <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
      ${filter.value}
    </ogc:Intersects>`;
  }

  private static createDateFilter(filter: OptionalFilter): string {
    const operator = filter.predicate === 'BIGGER_THAN' ? 'PropertyIsGreaterThan' : 'PropertyIsLessThan';
    return `<ogc:${operator}>
      <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
      <ogc:Literal>${filter.value}</ogc:Literal>
    </ogc:${operator}>`;
  }

  private static createHyloggedFilter(): string {
    return `<ogc:PropertyIsEqualTo>
      <ogc:PropertyName>gsmlp:nvclCollection</ogc:PropertyName>
      <ogc:Literal>true</ogc:Literal>
    </ogc:PropertyIsEqualTo>`;
  }

  private static combineFilters(filters: string[]): string {
    const validFilters = filters.filter(f => f);
    return validFilters.length > 1
      ? `<ogc:Filter><ogc:And>${validFilters.join('')}</ogc:And></ogc:Filter>`
      : `<ogc:Filter>${validFilters[0]}</ogc:Filter>`;
  }
}
