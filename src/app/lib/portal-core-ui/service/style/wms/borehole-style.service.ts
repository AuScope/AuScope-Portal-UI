import { Injectable } from '@angular/core';
import { StyleService } from './style.service';
import { serialize } from '@thi.ng/hiccup';

interface BoreholeStyleParams {
  filterNames?: string[];
  filters?: string[];
  filterColors?: string[];
  filterMarks?: string[];
  gsmlpNamespace: string;
  showLabels?: boolean;
  showNoneHylogged?: boolean;
  optionalFilters?: OptionalFilter[];
}

interface OptionalFilter {
  value: string;
  label: string;
  xpath: string;
  predicate: string;
  type: string;
  added: boolean;
}

@Injectable()
export class BoreholeStyleService {
  constructor(private styleService: StyleService) {}

  public static getSld(layerName: string, styleName: string, param: BoreholeStyleParams): string {
    const styleParams = {
        gsmlpNamespace:
          param?.gsmlpNamespace ||
          'http://xmlns.geosciml.org/geosciml-portrayal/4.0',
        showLabels: param?.showLabels !== false,
        showNoneHylogged: param?.showNoneHylogged,
        optionalFilters: param?.optionalFilters,
      };
    const ns = {
      sld: 'http://www.opengis.net/sld',
      ogc: 'http://www.opengis.net/ogc',
      gml: 'http://www.opengis.net/gml',
      gsml: 'urn:cgi:xmlns:CGI:GeoSciML:2.0',
      gsmlp: styleParams.gsmlpNamespace,
      xlink: 'http://www.w3.org/1999/xlink',
      xsi: 'http://www.w3.org/2001/XMLSchema-instance'
    };

    // Create rules based on filters
    const rules = this.createBoreholeRules(styleParams, ns);

    return serialize(
      ['sld:StyledLayerDescriptor', { 
        version: '1.0.0',
        'xmlns:sld': ns.sld,
        'xmlns:ogc': ns.ogc,
        'xmlns:gml': ns.gml,
        'xmlns:gsml': ns.gsml,
        'xmlns:gsmlp': ns.gsmlp,
        'xmlns:xlink': ns.xlink,
        'xmlns:xsi': ns.xsi,
        'xsi:schemaLocation': [
          `${ns.sld} StyledLayerDescriptor.xsd`,
          `${ns.gml} http://schemas.opengis.net/gml/3.1.1/base/gml.xsd`,
          `${ns.gsml} http://schemas.geosciml.org/geosciml/2.0/geosciml.xsd`
        ].join(' ')
      },
        ['sld:NamedLayer', {},
          ['sld:Name', {}, layerName],
          ['sld:UserStyle', {},
            ['sld:Name', {}, styleName],
            ['sld:Title', {}, styleName],
            ['sld:Abstract', {}, 'Borehole style generated by AuScope Portal'],
            ['sld:IsDefault', {}, '1'],
            ...rules
          ]
        ]
      ]
    );
  }

  private static createBoreholeRules(params: BoreholeStyleParams, ns: any): any[] {
    const rules = [];
    
    // Add regular boreholes
    const baseFilter = this.createBaseFilter(params.optionalFilters || []);
    rules.push(this.createRule(
      'Boreholes',
      baseFilter,
      '#2242c7',
      'circle',
      ns
    ));

    // Add hylogged boreholes if requested
    if (params.showNoneHylogged) {
      const hyloggedFilter = this.combineFilters([
        baseFilter,
        this.createHyloggedFilter()
      ]);
      rules.push(this.createRule(
        'Hylogged',
        hyloggedFilter,
        '#FF0000',
        'circle',
        ns
      ));
    }

    return rules;
  }

  private static createBaseFilter(filters: OptionalFilter[]): string {
    const filterParts: string[] = [];

    // Process optional filters
    filters.forEach(filter => {
      switch (filter.type) {
        case 'OPTIONAL.POLYGONBBOX':
          filterParts.push(this.createPolygonFilter(filter));
          break;
        case 'OPTIONAL.DATE':
          filterParts.push(this.createDateFilter(filter));
          break;
        case 'OPTIONAL.TEXT':
          if (filter.xpath === 'gsmlp:name') {
            // Handle name filter with substring search (contains)
            const searchValue = filter.value ? `*${filter.value}*` : '*';
            const nameFilterXml = `<ogc:PropertyIsLike wildCard="*" singleChar="#" escapeChar="!" matchCase="false">
            <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
            <ogc:Literal>${searchValue}</ogc:Literal>
            </ogc:PropertyIsLike>`;
            filterParts.push(nameFilterXml);
          }
          break;
        }
    });

    // Combine all filters with AND
    return filterParts.length > 1
      ? `<ogc:Filter><ogc:And>${filterParts.join('')}</ogc:And></ogc:Filter>`
      : filterParts[0] || this.generateDefaultFilter(null);
  }

  private static createPolygonFilter(filter: OptionalFilter): string {
    return `<ogc:Intersects>
      <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
      ${filter.value}
    </ogc:Intersects>`;
  }

  private static createDateFilter(filter: OptionalFilter): string {
    const operator = filter.predicate === 'BIGGER_THAN' ? 'PropertyIsGreaterThan' : 'PropertyIsLessThan';
    return `<ogc:${operator}>
      <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
      <ogc:Literal>${filter.value}</ogc:Literal>
    </ogc:${operator}>`;
  }

  private static createHyloggedFilter(): string {
    return `<ogc:PropertyIsEqualTo>
      <ogc:PropertyName>gsmlp:nvclCollection</ogc:PropertyName>
      <ogc:Literal>true</ogc:Literal>
    </ogc:PropertyIsEqualTo>`;
  }

  private static combineFilters(filters: string[]): string {
    const validFilters = filters.filter(f => f);
    return validFilters.length > 1
      ? `<ogc:Filter><ogc:And>${validFilters.join('')}</ogc:And></ogc:Filter>`
      : `<ogc:Filter>${validFilters[0]}</ogc:Filter>`;
  }

  private static createRule(name: string, filter: string, color: string, mark: string, ns: any): any[] {
    const filterXml = filter 
        ? (filter.includes('<ogc:Filter>') ? filter : ['ogc:Filter', {}, filter])
        : this.generateDefaultFilter(ns);
    
    return [
        'sld:FeatureTypeStyle', {},
        ['sld:Rule', {},
            ['sld:Name', {}, name],
            ['sld:MaxScaleDenominator', {}, '4000000'],
            typeof filterXml === 'string' ? filterXml : filterXml,
            this.createSymbolizer(color, mark, ns),
            this.createLabelSymbolizer(ns)
        ],
        [
            'sld:Rule', {},
            ['sld:MinScaleDenominator', {}, '4000000'],
            typeof filterXml === 'string' ? filterXml : filterXml,
            this.createSymbolizer(color, mark, ns)
        ]
    ];
  }

  private static createSymbolizer(color: string, mark: string, ns: any): any[] {
    return [
      'sld:PointSymbolizer', {},
      ['sld:Graphic', {},
        ['sld:Mark', {},
          ['sld:WellKnownName', {}, mark],
          ['sld:Fill', {},
            ['sld:CssParameter', { name: 'fill' }, color],
            ['sld:CssParameter', { name: 'fill-opacity' }, '0.4']
          ],
          ['sld:Stroke', {},
            ['sld:CssParameter', { name: 'stroke' }, color],
            ['sld:CssParameter', { name: 'stroke-width' }, '0.5']
          ]
        ],
        ['sld:Size', {}, '8']
      ]
    ];
  }

  private static createLabelSymbolizer(ns: any): any[] {
    return [
      'sld:TextSymbolizer', {},
      ['sld:Label', {},
        ['ogc:Function', { name: 'strSubstringStart' },
          ['ogc:PropertyName', {}, 'gsmlp:name'],
          ['ogc:Function', { name: 'parseInt' },
            ['ogc:Literal', {}, '27']
          ]
        ]
      ],
      ['sld:Font', {},
        ['sld:CssParameter', { name: 'font-family' }, 'Arial'],
        ['sld:CssParameter', { name: 'font-size' }, '12']
      ],
      ['sld:LabelPlacement', {},
        ['sld:PointPlacement', {},
          ['sld:Displacement', {},
            ['sld:DisplacementX', {}, '6'],
            ['sld:DisplacementY', {}, '-6']
          ]
        ]
      ],
      ['sld:Fill', {},
        ['sld:CssParameter', { name: 'fill' }, '#000000']
      ]
    ];
  }

  private static generateDefaultFilter(ns: any): string {
    return `<ogc:Filter><ogc:PropertyIsLike wildCard="*" singleChar="#" escapeChar="!">
              <ogc:PropertyName>gsmlp:name</ogc:PropertyName>
              <ogc:Literal>*</ogc:Literal>
            </ogc:PropertyIsLike></ogc:Filter>`;
  }

  public static generateFilter(property: string, values: string[], ns: any): string {
    if (!values || values.length === 0) {
        return this.generateDefaultFilter(ns);
    }

    if (values[0] && values[0].includes('<ogc:Filter>')) {
        return values.length > 1 
            ? `<ogc:Filter><ogc:And>${values.join('')}</ogc:And></ogc:Filter>`
            : values[0];
    }

    const filters = values.map(value => 
        StyleService.getFilter(property, value, false)
            .replace(/ogc:/g, `${ns.ogc}:`)
            .replace(/sld:/g, `${ns.sld}:`)
    );
    
    return filters.length > 1 
        ? `<${ns.ogc}:Or>${filters.join('')}</${ns.ogc}:Or>`
        : filters[0];
  }
} 